import pygame #for creating games in python
import numpy as np #for math functions
import time
from playsound import playsound
from pygame import mixer

pygame.init()

mixer.init()
mixer.music.load('music.ogg')
mixer.music.play(-1) #music plays infinite



width, height = 700, 700 #screen
screen = pygame.display.set_mode((height, width))

bg = 25, 25, 25
screen.fill(bg)

nxC, nyC = 50, 50 #n cells
#height width of cells
dimCW = width / nxC
dimCH = height / nyC

gameState = np.zeros((nxC, nyC)) #all states of a cell: death 0 or alive 1

#life autogenerated
""" stick """
gameState[5, 3] = 1
gameState[5, 4] = 1
gameState[5, 5] = 1

""" moving """
gameState[21, 21] = 1
gameState[22, 22] = 1
gameState[22, 23] = 1
gameState[21, 23] = 1
gameState[20, 23] = 1


#game execution control
pauseExect = False
running = True

#execution
while running:

           
    #changes must be in every "time unit"
    newGameState = np.copy(gameState)

    #cleaning screen in each iteration to not overlap white cells
    screen.fill(bg)
    time.sleep(0.08) #a bit of delay in secs

    #user inputs
    ev = pygame.event.get()

    for event in ev:
        if event.type == pygame.KEYDOWN: #pause game
            pauseExect = not pauseExect
            #close app with escape key
            if event.key == pygame.K_ESCAPE:
                running = False

        #close app with close window icon
        if event.type == pygame.QUIT:
            running = False

        #detecting if mouse is pressed
        mouseClick = pygame.mouse.get_pressed()
        
        if sum(mouseClick) > 0: #if mouse pressed
            posX, posY = pygame.mouse.get_pos() #mouse position (in pixels)
            celX, celY = int(np.floor(posX / dimCW)), int(np.floor(posY / dimCH)) #getting position
            newGameState[celX, celY] = 1 #reviving pressed cell

    #for printing
    for y in range(0, nxC):
        for x in range(0, nyC):

            if not pauseExect:

                #number of neighbours
                n_neigh = gameState[(x-1) % nxC, (y-1) % nyC]+\
                        gameState[(x) % nxC, (y-1) % nyC]+\
                        gameState[(x+1) % nxC, (y-1) % nyC]+\
                        gameState[(x-1) % nxC, (y) % nyC]+\
                        gameState[(x+1) % nxC, (y) % nyC]+\
                        gameState[(x-1) % nxC, (y+1) % nyC]+\
                        gameState[(x) % nxC, (y+1) % nyC]+\
                        gameState[(x+1) % nxC, (y+1) % nyC]

                #RULE 1: a cell with exactly 3 alive neighbours, lives
                if gameState[x, y] == 0 and n_neigh == 3:
                    newGameState[x, y] = 1

                #RULE 2: a cell with less than 2 or more than 3 alive neighbours, dies
                elif gameState[x, y] == 1 and (n_neigh < 2 or n_neigh > 3):
                    newGameState[x, y] = 0


            #coordinates of rectangle
            poly = [((x) * dimCW, y * dimCH),((x+1) * dimCW, y * dimCH),
                    ((x+1) * dimCW, (y+1) * dimCH), ((x) * dimCW, (y+1) * dimCH)]
            #drawing cell for each pair of x and y
            if newGameState[x, y] == 0:
                pygame.draw.polygon(screen, (128, 128, 128), poly, 1) #color, points of polygon and width
            else:
                pygame.draw.polygon(screen, (255, 255, 255), poly, 0) #drawing white cell (alive)


    #updating game state
    gameState = np.copy(newGameState)

    pygame.display.flip() #displaying frames

pygame.quit()